/* *    Hi, Code Enthusiast! *    https://github.com/yudiatmoko */package com.iyam.catatanku.dataimport android.content.Contextimport com.iyam.catatanku.Rimport java.io.BufferedReaderimport java.io.Fileimport java.io.FileOutputStreamimport java.io.FileReaderimport java.io.IOExceptionimport java.text.SimpleDateFormatimport java.util.Arraysimport java.util.Dateinterface NoteRepository {    fun createFile(fileName: String, data: String, callback: FileCallback)    fun readFile(fileName: String): String    fun getFiles(dataList: ArrayList<Map<String, Any>>, callback: FileCallback)    fun deleteFile(fileName: String, callback: FileCallback)    fun updateFile(fileName: String, data: String, callback: FileCallback)}class NoteRepositoryImpl(    private val context: Context,) : NoteRepository {    private val path = context.filesDir.absolutePath + context.getString(R.string.dir_name)    companion object {        const val NAME = "name"        const val DATE = "date"    }    override fun createFile(fileName: String, data: String, callback: FileCallback) {        val file = File(path, fileName)        val parent = File(path)        if (!parent.exists()) {            parent.mkdir()        }        when {            fileName.isEmpty() -> callback.onError(context.getString(R.string.file_name_required))            file.exists() -> callback.onError(context.getString(R.string.file_name_already_exist_text))            else -> {                try {                    file.createNewFile()                    FileOutputStream(file, false).use { fos ->                        fos.write(data.toByteArray())                        fos.flush()                    }                    callback.onSuccess()                } catch (e: IOException) {                    callback.onError(e.message.toString())                }            }        }    }    override fun readFile(fileName: String): String {        val file = File(path, fileName)        if (file.exists()) {            val text = StringBuilder()            try {                val br = BufferedReader(FileReader(file))                var line = br.readLine()                while (line != null) {                    text.append(line).append("\n")                    line = br.readLine()                }                br.close()            } catch (e: IOException) {                e.printStackTrace()            }        }        return file.readText()    }    override fun getFiles(dataList: ArrayList<Map<String, Any>>, callback: FileCallback) {        val fileDirectory = File(path)        val files = fileDirectory.listFiles()        dataList.clear()        if (files != null && files.isNotEmpty()) {            Arrays.sort(files) { f1: File, f2: File ->                f2.lastModified().compareTo(f1.lastModified())            }            val dateFormat = SimpleDateFormat(context.getString(R.string.dd_mmm_yyy_hh_mm))            for (file in files) {                val lastModifiedDate = Date(file.lastModified())                val fileName = file.name                val fileDate = dateFormat.format(lastModifiedDate)                val listItemMap: MutableMap<String, Any> = HashMap()                listItemMap[NAME] = fileName                listItemMap[DATE] = fileDate                dataList.add(listItemMap)            }            callback.onSuccess()        }    }    override fun deleteFile(fileName: String, callback: FileCallback) {        val file = File(path, fileName)        if (file.exists()) {            file.delete()            callback.onSuccess()        }    }    override fun updateFile(fileName: String, data: String, callback: FileCallback) {        val file = File(path, fileName)        val outputStream: FileOutputStream        try {            file.createNewFile()            outputStream = FileOutputStream(file, false)            outputStream.write(data.toByteArray())            outputStream.flush()            outputStream.close()            callback.onSuccess()        } catch (e: IOException) {            callback.onError(e.message.toString())        }    }}